# 1. 인터페이스
클래스를 정의할때 반드시 들어가야 하는 변수와 함수를 지정할 때 사용.

강제성을 띄운다.

abstract class로 선언

implements 키워드 사용!
```dart
abstract class Food{
  String name;
  void sayName();
}

class Pizza implements Food{
  String name = "pizza";
  void sayName(){ //일종의 overiding
    print("이 음식은 피자입니다");
  }
}
```

# 2. 확장
사용방법 : extension <extension name> on <type> { (<member definition>)* }
  
```dart
// 확장함수
extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }
  // ···
}


// 아래와 같이 사용할 수 있다
import 'string_apis.dart';
...
print('42'.padLeft(5)); // Use a String method.

int.parse('42')
print('42'.parseInt()); // 위와 같지만 이처럼 String 확장함수로 사용 가능
```
  
# 3. 제너릭
< >으로 타입을 지정할 수 있다.
```dart
  abstract class StringTest{
  String getTest(String i);
  void setTest(String i);
}
abstract class Test<T>{
  T getTest(T i);
  void setTest(T i);
}
```
기본적으로 타입마다 지정해야 될 수 있었던 상황을 제네릭으로 코드의 중복을 막을 수 있다.

