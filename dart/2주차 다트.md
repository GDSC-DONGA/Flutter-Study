# Getter & Setter
의도하지 않은 곳에서 접근해 값을 변경하는 일을 방지하기 위해 클래스 내부 정보를 은닉하는 방식을 캡슐화라고 한다.
특정 멤버 변수에 접근할 수 있는 특별한 기능을 하는 메서드를 Getter, Setter메서드라고 한다.
Getter는 멤버 변수 값을 가져오는 역할을, Setter는 값을 쓰는 역할을 한다.

```dart
class Person {
  String? _name;
  String? get name => _name;   
  set name(String? name) => _name = name;
}
/* 여기서 name은 멤버변수에 접근할 때 사용할 이름이다. name이라는 이름으로 _name에 접근할 수 있는 것이다.*/

main() {
  Person person = Person();
  person.name = 'Kim';
  print(person.name);
}
```
> Kim


# 인터페이스
dart에서는 인터페이스를 class로 선언해 사용한다.
구헌 클래스에서 인터페이스를 implements 하면된다.
```dart
class WorldInterface {
  String? name;
  void sayName(){}
}

class Korea implements WorldInterface{
  String? name;
  Korea(
    String? name,
  ):this.name= name;
  
  void sayName(){
    print('이 나라의 이름은 ${this.name}입니다.');
  }
}

class Usa implements WorldInterface {
  String? name;
  
  Usa(
    String? name,
  ):this.name = name;
  
  void sayName(){
    print('이 나라의 이름은 ${this.name}입니다.');
  }
}

void main() {
  Korea korea = Korea('한국');
  korea.sayName();
  Usa usa = Usa('미국');
  usa.sayName();
}
```
> 이 나라의 이름은 한국입니다.<br>
> 이 나라의 이름은 미국입니다.


abstarct라는 이름으로 추상클래스를 먼저 선언하고 implements를 통해 인터페이스를 구현하는 방법도 가능하다.
```dart
abstract class Person {
  final String? name;
  Person(this.name);
  String sex();
  String age();
  String eat() => '$name eats nothing';
  String say() => '$name says nothing';
}

class John implements Person {
  @override
  String? get name => 'John';
  
  @override
  String sex() => '$name is male';
  
  @override
  String age() => '$name is 20';
  
  @override
  String eat() => '$name eats pizza';
  
  @override
  String say() => '$name says something';
}

main() {
  John john = John();
  print(john.sex());
  print(john.age());
  print(john.eat());
  print(john.say());
}
```
> John is male
> John is 20
> John eats pizza
> John says something

implements가 사용되면 Person의 모든 변수와 함수가 의무적으로 재정의되어야 한다.

# 상속
extends를 통해 상속을 하는 경우에는 의무적으로 재정의해야하는 것은 추상 함수뿐이다.
```dart
abstract class Person {
  final String? name;
  Person(this.name);
  String sex(); /*추상함수*/
  String age(); /*추상함수*/
  String eat() => '$name eats nothing';
  String say() => '$name says nothing';
}

class Jane extends Person {
  Jane(String name) : super(name);
  
  @override
  String sex() => '$name is female';
  
  @override
  String age() => '$name is 21';
}
```
나머지 함수들은 필요한 경우에 선택적으로 재정의 할 수 있다.

```dart
abstract class Person {
  final String? name;
  Person(this.name);
  String sex();
  String age();
  String eat() => '$name eats nothing';
  String say() => '$name says nothing';
}

abstract class Male extends Person {
  Male(String name) : super(name);
  
  @override
  String sex() => '$name is a male';
}

class Mike extends Male {
  Mike(String name) : super(name);
  
  @override
  String age() => '$name is 22';
  
  @override
  String eat() => '$name eats burger';
}

main() {
  Mike mike = Mike('mike');
  print(mike.age());
  print(mike.eat());
  print(mike.sex());
  print(mike.say());
}
```
> mike is 22
> mike eats burger
> mike is a male
> mike says nothing

위처럼 여러 단계의 상속이 필요한 경우 implements가 아니라 extends를 활용하면 된다. mike클래스는 male을 상속하면서 자연스럽게 Person까지 상속받게 되는 것이다.


# Extension 확장

